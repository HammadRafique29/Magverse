<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>My Electron App</title>
    <link rel="stylesheet" href="styles/index.css">
    <link rel="stylesheet" href="styles/scenes.css">
</head>

<body>
    <header>
        <div class="navbar">
            <h1>Story Generator<span class="tagline">. Generate Animated Story With AI</span></h1>
        </div>
    </header>

    <div class="content" style="row-gap: 30px;align-items: center;justify-content: center;">
        <div id="message">
            <p>We generated some Scenes for you</p>
        </div>

        <div id="AI_generated_scenes"></div>
        <input type="text" name="hidden_" id="hidden_story_id_" style="display: none;">
            

        <div class="page_controls_container" style="position: absolute;bottom: 10px;">
            <button onclick="history.back();" class="page_control_" id="back_">
                Back
            </button>
            <button class="page_control_" id="next_">
                Generate Audio
            </button>
        </div>

    </div>

    <script type="module">

        import { generate_scenes, refresh_scene, update_scene, get_story } from './scripts/scenes.js';

        const ai_generated_scenes = document.getElementById("AI_generated_scenes");
        const hidden_story_id_ = document.getElementById("hidden_story_id_");

        async function generate_ai_scenes() {

            const story_data = JSON.parse(localStorage.getItem('story_data'));
            console.log(story_data);

            let test_scenes = null;
            const draft_story = JSON.parse(localStorage.getItem('story_data'));
            console.log(draft_story);
            
            test_scenes = (draft_story && draft_story.draft_story) ? draft_story.draft_story : await generate_scenes(story_data.prompt, story_data.duration);
        }

        window.addEventListener('DOMContentLoaded', async () => {
            const story_data = JSON.parse(localStorage.getItem('story_data'));
            console.log(story_data);

            let test_scenes = null;
            const draft_story = JSON.parse(localStorage.getItem('story_data'));
            console.log(draft_story);
            test_scenes = (draft_story && draft_story.draft_story) ? draft_story.draft_story : await generate_scenes(story_data.prompt, story_data.duration);

            if (story_data) {

                test_scenes.scenes.forEach((scene, index) => renderSceneCard(scene, index, test_scenes.story_id, draft_story && draft_story.draft_story ? true : false, true));

                // Attach event listeners once DOM is populated
                ai_generated_scenes.addEventListener('click', async (event) => {
                    const target = event.target.closest('button');
                    if (!target) return;

                    if (target.classList.contains('refresh_prompt_btn_')) {
                        await handleSceneInteraction(target, true);
                    } else if (target.classList.contains('update_prompt_btn_')) {
                        await handleSceneInteraction(target, false);
                    }
                });
                // const temp_scenes_obj = [
                //     {scene_id: "1", scene: "Loading...", imagePrompt: "Loading..." },
                //     {scene_id: "1", scene: "Loading...", imagePrompt: "Loading..." },
                //     {scene_id: "1", scene: "Loading...", imagePrompt: "Loading..." },
                //     {scene_id: "1", scene: "Loading...", imagePrompt: "Loading..." },
                //     {scene_id: "1", scene: "Loading...", imagePrompt: "Loading..." },
                //     {scene_id: "1", scene: "Loading...", imagePrompt: "Loading..." }
                // ]
                // temp_scenes_obj.forEach((scene, index) => renderSceneCard(scene, index, "12345678", false, true));
                document.getElementById("next_").addEventListener('click', async (event) => { await generate_audio_page() });
            }

            function renderSceneCard(scene, index, storyId, old_scene = false, isTempLoadingObj = false) {
                const { scene_id: sceneId, scene: sceneText, imagePrompt } = scene;

                if (!isTempLoadingObj) {
                    document.querySelectorAll('.temporary_loading_obj').forEach(el => {
                        el.replaceWith(el.cloneNode(false));
                        el.remove();
                        el = null;
                    });
                }

                const elem_html = `
                    <div id="scene_${sceneId}" class="generated_scenes_ loading_state_ ${isTempLoadingObj? 'temporary_loading_obj': ''}">
                        <div class="loading_overlay_full_">
                            <div class="shimmer_"></div>
                            <div class="spinner_circle"></div>
                        </div>

                        <div class="scene_content_" style="display: none;height: 200px;">
                            <div class="scene_ids_">Scene${index + 1}</div>
                            <div class="scene_prompt_">
                                <textarea class="scene_prompt_textarea" name="scene_output_${sceneId}" id="scene_output_${sceneId}" cols="30"></textarea>
                            </div>
                            <div class="scenes_controls_">
                                <button type="button" class="refresh_prompt_btn_" data-story-id="${storyId}" data-scene-id="${sceneId}">
                                    <img src="../assets/img/refresh.png" width="30" height="30" alt="">
                                </button>
                                <button class="update_prompt_btn_" data-story-id="${storyId}" data-scene-id="${sceneId}">Update</button>
                            </div>
                            <input type="hidden" id="hidden_image_prompt_${sceneId}" data-story-id="${storyId}" data-scene-id="${sceneId}">
                        </div>
                    </div>
                `;

                ai_generated_scenes.insertAdjacentHTML('beforeend', elem_html);
                const delay =  Math.floor((!old_scene ? Math.random() : 0.02) * 4000 ) + 1000;
                hidden_story_id_.value = storyId;
                setTimeout(() => populateSceneContent(sceneId, sceneText, imagePrompt), delay);
            }

            function populateSceneContent(sceneId, sceneText, imagePrompt) {
                const container = document.getElementById(`scene_${sceneId}`);
                const overlay = container.querySelector('.loading_overlay_full_');
                const content = container.querySelector('.scene_content_');

                container.querySelector(`#scene_output_${sceneId}`).value = sceneText;
                container.querySelector(`#hidden_image_prompt_${sceneId}`).value = imagePrompt;

                overlay.style.opacity = 0;
                overlay.style.pointerEvents = 'none';

                content.style.display = 'block';
                setTimeout(() => content.classList.add('fade_in_show_'), 50);
            }


            async function handleSceneInteraction(button, isRefresh) {
                const sceneId = button.getAttribute('data-scene-id');
                const storyId = button.getAttribute('data-story-id');
                const container = document.getElementById(`scene_${sceneId}`);
                const overlay = container.querySelector('.loading_overlay_full_');
                const content = container.querySelector('.scene_content_');
                const textarea = container.querySelector(`#scene_output_${sceneId}`);
                const hiddenInput = container.querySelector(`#hidden_image_prompt_${sceneId}`);

                const originalValue = textarea.value;
                if (isRefresh) textarea.value = "";
                showOverlay(overlay, content);

                try {
                    const response = isRefresh
                        ? await refresh_scene(storyId, sceneId)
                        : await update_scene(storyId, sceneId, textarea.value);

                    setTimeout(() => {
                        if (!response) {
                            alert(`Failed to ${isRefresh ? "refresh" : "update"} scene. Please try again.`);
                            console.error(`Failed to ${isRefresh ? "refresh" : "update"} scene`);
                            if (isRefresh) textarea.value = originalValue;
                        } else {
                            textarea.value = response.scene;
                            hiddenInput.value = response.imagePrompt;
                        }
                        hideOverlay(overlay, content);
                    }, 1500 + Math.random() * 1000);
                } catch (err) {
                    console.error(err);
                    hideOverlay(overlay, content);
                }
            }

            function showOverlay(overlay, content) {
                overlay.style.opacity = 1;
                overlay.style.pointerEvents = 'all';
                content.classList.remove('fade_in_show_');
            }

            function hideOverlay(overlay, content) {
                overlay.style.opacity = 0;
                overlay.style.pointerEvents = 'none';
                setTimeout(() => content.classList.add('fade_in_show_'), 50);
            }

            async function generate_audio_page() {

                const updated_story_data = await get_story(hidden_story_id_.value);
                localStorage.setItem('story_data', JSON.stringify({
                        prompt: story_data.prompt,
                        video_dur: story_data.video_dur,
                        video_res: story_data.video_res,
                        story_id: hidden_story_id_.value,
                        draft_story: updated_story_data,
                    }));

                window.location.href = 'generate_audio.html';
            }

            function go_back() {
                history.back();
            }

        });

        

    </script>


</body>

</html>